/*
 * Algoritmos.java
 *
 * Created on 2 de septiembre de 2007, 06:06 PM
 */

package gui.manual;

/**
 *
 * @author  TNRsoft
 */
public class Algoritmos extends javax.swing.JPanel {
    
    /** Creates new form Algoritmos */
    public Algoritmos() {
        initComponents();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        jLabel17 = new javax.swing.JLabel();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel18 = new javax.swing.JLabel();
        jTextArea2 = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jLabel19 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jTextArea3 = new javax.swing.JTextArea();
        jLabel20 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jTextArea4 = new javax.swing.JTextArea();
        jTextArea5 = new javax.swing.JTextArea();
        jLabel21 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jTextArea6 = new javax.swing.JTextArea();
        jLabel5 = new javax.swing.JLabel();
        jTextArea7 = new javax.swing.JTextArea();

        setBackground(new java.awt.Color(255, 255, 255));
        jLabel17.setFont(new java.awt.Font("Berlin Sans FB Demi", 0, 18));
        jLabel17.setForeground(new java.awt.Color(58, 123, 252));
        jLabel17.setText("Algoritmos de Clasificaci\u00f3n");

        jTextArea1.setColumns(20);
        jTextArea1.setFont(new java.awt.Font("Berlin Sans FB Demi", 0, 14));
        jTextArea1.setRows(5);
        jTextArea1.setText("Clasificaci\u00f3n: se asigna los registros de datos en categor\u00edas predefinidas. Los datos son objetos caracterizados \npor atributos que pertenecen a diferentes clases. La meta es inducir un modelo para poder predecir una clase \ndados los valores de los atributos. Se utiliza \u00c1rboles de decisi\u00f3n que son  estructuras de forma de \u00e1rbol que \nrepresentan conjuntos de decisiones. Estas decisiones generan reglas para la clasificaci\u00f3n de un conjunto de \ndatos.\nEn esta herramienta se han implementado 3 tipos de algoritmos que son los suiguientes:\n");
        jTextArea1.setCaretColor(new java.awt.Color(255, 255, 255));

        jLabel18.setFont(new java.awt.Font("Berlin Sans FB Demi", 0, 18));
        jLabel18.setForeground(new java.awt.Color(58, 123, 252));
        jLabel18.setText("Mate Tree");

        jTextArea2.setColumns(20);
        jTextArea2.setFont(new java.awt.Font("Berlin Sans FB Demi", 0, 14));
        jTextArea2.setRows(5);
        jTextArea2.setText("Mate-tree es un algoritmo propuesto por Timar\u00e1n, se basa en los nuevos operadores del \u00e1lgebra relacional Mate, \nDescribe Classifier, y las funciones agregadas Entro( ) y Gain( ) para la generaci\u00f3n de reglas de clasificaci\u00f3n \npropuestos por tambien por Timar\u00e1n. El algoritmo es el siguiente .\n\nEl primer paso del algoritmo calcula la Entrop\u00eda del atributo clase de la relaci\u00f3n R. En el subsiguiente paso, se aplica \nel operador Mate con el fin de generar todas las posibles combinaciones de los atributos condici\u00f3n con el atributo clase. \n\nSe cuenta el n\u00famero de ocurrencias de cada combinaci\u00f3n y a la relaci\u00f3n resultante R1, se aplica la funci\u00f3n agregada \nEntro() que calcula para cada combinaci\u00f3n de atributos condici\u00f3n y clase la entrop\u00eda de la relaci\u00f3n R1 con respecto a estos \natributos. Posteriormente se calcula con la funci\u00f3n agregada Gain(), la ganancia de Informaci\u00f3n obtenida por el \nparticionamiento de la relaci\u00f3n R1 por las diferentes combinaciones de atributos condici\u00f3n y clase.\n \nFinalmente con la relaci\u00f3n resultante R2, el operador describe classifier construye el \u00e1rbol de decisi\u00f3n. \n");
        jTextArea2.setCaretColor(new java.awt.Color(255, 255, 255));

        jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/images/Herramienta/iconoMate2.png")));

        jLabel19.setFont(new java.awt.Font("Berlin Sans FB Demi", 0, 18));
        jLabel19.setForeground(new java.awt.Color(58, 123, 252));
        jLabel19.setText("C4.5");

        jLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/images/Herramienta/iconoC45.png")));

        jTextArea3.setColumns(20);
        jTextArea3.setFont(new java.awt.Font("Berlin Sans FB Demi", 0, 14));
        jTextArea3.setRows(5);
        jTextArea3.setText("El algoritmo C4.5 fue pensado para los casos en los que se tiene gran cantidad de objetos y atributos y se requiere \nla construcci\u00f3n de un \u00e1rbol de clasificaci\u00f3n sin mucho tiempo computacional. La estructura b\u00e1sica del algoritmo es \niterativa. Se divide el conjunto de datos en subconjuntos de entrenamiento y prueba, como resultado se obtiene \nun \u00e1rbol capaz de clasificar todos los elementos de conjunto de entrenamiento, entonces el proceso termina, \nen caso contrario, se a\u00f1aden los objetos no clasificados nuevamente a los datos de entrenamiento y el proceso \ncontin\u00faa. El problema por tanto radica en los criterios para el c\u00e1lculo del \u00e1rbol para una cantidad arbitraria de \nobjetos. El punto crucial en el c\u00e1lculo del \u00e1rbol est\u00e1 en la elecci\u00f3n del mejor atributo. C4.5 utiliza la entrop\u00eda de\n Shannon para esta decisi\u00f3n y se demuestra que el costo computacional por cada iteraci\u00f3n en C4.5 es proporcional \nal producto del tama\u00f1o del conjunto de entrenamiento, el n\u00famero de atributos y el n\u00famero de nodos que no son \nhojas del \u00e1rbol. C4.5 consta de un sistema de aprendizaje que obtiene reglas de clasificaci\u00f3n y que utiliza \u00e1rboles \ncomo modelo de representaci\u00f3n.");
        jTextArea3.setCaretColor(new java.awt.Color(255, 255, 255));

        jLabel20.setFont(new java.awt.Font("Berlin Sans FB Demi", 0, 18));
        jLabel20.setForeground(new java.awt.Color(58, 123, 252));
        jLabel20.setText("Sliq");

        jLabel3.setIcon(new javax.swing.ImageIcon(getClass().getResource("/images/Herramienta/iconoSliq.png")));

        jTextArea4.setColumns(20);
        jTextArea4.setFont(new java.awt.Font("Berlin Sans FB Demi", 0, 14));
        jTextArea4.setRows(5);
        jTextArea4.setText("SLIQ es un clasificador que usa \u00e1rboles de decisi\u00f3n y que pude manejar tanto  atributos num\u00e9ricos como categoriales. \nTambi\u00e9n usa una t\u00e9cnica de pre-clasificaci\u00f3n en la etapa de construcci\u00f3n del \u00e1rbol para reducir el coste de la evaluaci\u00f3n \nde particiones por atributos num\u00e9ricos. Este proceso de clasificaci\u00f3n se integra con una estrategia de crecimiento del \u00e1rbol \nprimero en anchura para permitir a SLIQ clasificar grandes bases de datos residentes en disco. Adem\u00e1s SLIQ usa un algoritmo \neficiente de obtenci\u00f3n de subconjuntos para determinar las particiones con atributos categoriales. Otra caracter\u00edstica interesante \nes el uso de un nuevo algoritmo de poda basado en el principio de Descripci\u00f3n de Longitud M\u00ednima (MDL, Minimun Description \nLength).\n\nEste algoritmo es poco costoso y produce \u00e1rboles compactos y eficaces. La combinaci\u00f3n de todo lo anterior hace que SLIQ posea\nuna gran escalabilidad y que sea capaz de clasificar grandes conjuntos de datos con un gran n\u00famero de valores de clases y  de \nlos atributos.");
        jTextArea4.setCaretColor(new java.awt.Color(255, 255, 255));

        jTextArea5.setColumns(20);
        jTextArea5.setFont(new java.awt.Font("Berlin Sans FB Demi", 0, 14));
        jTextArea5.setRows(5);
        jTextArea5.setText("todos los \u00edconos de clasificaci\u00f3n contienen las mismas funciones; el submen\u00fa se lo obtiene dando click derecho sobre el \u00edcono situado \nen el \u00e1rea de trabajo");
        jTextArea5.setCaretColor(new java.awt.Color(255, 255, 255));

        jLabel21.setFont(new java.awt.Font("Berlin Sans FB Demi", 0, 18));
        jLabel21.setForeground(new java.awt.Color(58, 123, 252));
        jLabel21.setText("Funcionamiento:");

        jLabel4.setIcon(new javax.swing.ImageIcon(getClass().getResource("/images/Herramienta/iconoMate.png")));

        jTextArea6.setColumns(20);
        jTextArea6.setFont(new java.awt.Font("Berlin Sans FB Demi", 0, 14));
        jTextArea6.setRows(5);
        jTextArea6.setText("- Borrar: borra el \u00edcono del \u00e1rea de trabajo\n- Configurar: se configura el n\u00famero menor de registros por cada hoja. Es necesario para poder ejecutar el algoritmo.\n");
        jTextArea6.setCaretColor(new java.awt.Color(255, 255, 255));

        jLabel5.setIcon(new javax.swing.ImageIcon(getClass().getResource("/images/Herramienta/paraClasificadores.png")));

        jTextArea7.setColumns(20);
        jTextArea7.setFont(new java.awt.Font("Berlin Sans FB Demi", 0, 14));
        jTextArea7.setRows(5);
        jTextArea7.setText("- Borrar: borra el \u00edcono del \u00e1rea de trabajo\n- Configurar: se configura el n\u00famero menor de registros por cada hoja. Es necesario para poder ejecutar el algoritmo.\n");
        jTextArea7.setCaretColor(new java.awt.Color(255, 255, 255));

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(layout.createSequentialGroup()
                        .add(250, 250, 250)
                        .add(jLabel17))
                    .add(layout.createSequentialGroup()
                        .addContainerGap()
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(jLabel18)
                            .add(jTextArea2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(layout.createSequentialGroup()
                                .add(341, 341, 341)
                                .add(jLabel1))
                            .add(jLabel19)
                            .add(jLabel20)))
                    .add(layout.createSequentialGroup()
                        .addContainerGap()
                        .add(jTextArea1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(layout.createSequentialGroup()
                        .add(316, 316, 316)
                        .add(jLabel2))
                    .add(layout.createSequentialGroup()
                        .addContainerGap()
                        .add(jTextArea3, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(layout.createSequentialGroup()
                        .addContainerGap()
                        .add(jTextArea4, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(layout.createSequentialGroup()
                        .add(338, 338, 338)
                        .add(jLabel3))
                    .add(layout.createSequentialGroup()
                        .add(19, 19, 19)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(jTextArea5, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(jLabel21)))
                    .add(layout.createSequentialGroup()
                        .add(247, 247, 247)
                        .add(jLabel4))
                    .add(layout.createSequentialGroup()
                        .addContainerGap()
                        .add(jTextArea6, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(layout.createSequentialGroup()
                        .add(198, 198, 198)
                        .add(jLabel5))
                    .add(layout.createSequentialGroup()
                        .addContainerGap()
                        .add(jTextArea7, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(2004, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jLabel17, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 27, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(48, 48, 48)
                .add(jTextArea1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(46, 46, 46)
                .add(jLabel18, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 27, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(19, 19, 19)
                .add(jLabel1)
                .add(20, 20, 20)
                .add(jTextArea2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(61, 61, 61)
                .add(jLabel19, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 27, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(14, 14, 14)
                .add(jLabel2)
                .add(23, 23, 23)
                .add(jTextArea3, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(43, 43, 43)
                .add(jLabel20, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 27, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(12, 12, 12)
                .add(jLabel3)
                .add(16, 16, 16)
                .add(jTextArea4, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(72, 72, 72)
                .add(jLabel21, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 27, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jTextArea5, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 51, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(30, 30, 30)
                .add(jLabel4)
                .add(26, 26, 26)
                .add(jTextArea6, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 51, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(29, 29, 29)
                .add(jLabel5)
                .add(47, 47, 47)
                .add(jTextArea7, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 51, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(105, 105, 105))
        );
    }// </editor-fold>//GEN-END:initComponents
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel20;
    private javax.swing.JLabel jLabel21;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextArea jTextArea3;
    private javax.swing.JTextArea jTextArea4;
    private javax.swing.JTextArea jTextArea5;
    private javax.swing.JTextArea jTextArea6;
    private javax.swing.JTextArea jTextArea7;
    // End of variables declaration//GEN-END:variables
    
}
